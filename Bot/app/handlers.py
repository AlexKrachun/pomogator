import logging
from aiogram import types, Bot
from aiogram.types import Message
from aiogram import Router, F
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext

from aiogram.filters import Command
from Bot.additioanl.message_templates import message_templates, get_changed_context_line
from Bot.app.keyboard import inline_contexts, inline_modes, inline_pay, dalle_3_settings
from Bot.app.openai_api import request_get_topic, generate_image, get_common_gpt_complection
from Bot.app.faceswap_api import run_face_swap
from Bot.app.anthropic_api import get_claude_text_response
from Bot.app.utils.decorators import processing_guard, block_not_llm_model, block_not_dalle_model

from db.main import db_client
from Bot.app.middlewares import UserRegistrationMiddleware

from Bot.app.utils.state import id_in_processing

import base64
import aiohttp
from dotenv import load_dotenv
import os

load_dotenv()
BOT_TOKEN = os.environ.get('BOT_TOKEN')

# logger = logging.getLogger(__name__)
logger = logging.getLogger('bot_logger')

router = Router()
router.message.middleware(UserRegistrationMiddleware())
router.callback_query.middleware(UserRegistrationMiddleware())


async def print_text_message(text: str, message: Message):
    if len(text) < 4096:

        # message.answer(text)
        try:
            await message.answer(text, parse_mode="Markdown")
        except Exception as e:
            print('1' * 100)
            print(e)
            await message.answer(text)


    else:
        while text != '':
            st = text[:min(4090, len(text))]

            if st.count('```') % 2 == 0:

                # message.answer(st)
                try:
                    await message.answer(st, parse_mode="Markdown")
                except Exception as e:
                    print('2' * 100)
                    print(e)
                    await message.answer(st)

                text = text[len(st):]
            else:

                # message.answer(st + '```')
                try:
                    await message.answer(st + '\n```', parse_mode="Markdown")
                except Exception as e:
                    print('3' * 100)
                    print(e)
                    await message.answer(st + '\n```')

                if not text:
                    break
                text = '```\n' + text[len(st):]


@router.message(Command('contexts'))
@processing_guard
@block_not_llm_model
async def language_cmd(message: types.Message):
    try:
        reply_markup = await inline_contexts(message.from_user.id)
        await message.answer(
            message_templates['ru']['contexts'],
            reply_markup=reply_markup
        )
        logger.debug("ÐžÑ‚Ð²ÐµÑ‚ Ð½Ð° /contexts ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½.")
    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ /contexts")
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /contexts.")


@router.message(Command('pay'))
async def pay_cmd(message: types.Message):
    try:
        await message.answer(
            'ÐŸÐ¾ÐºÐ° Ñ‚ÑƒÑ‚ Ð²ÑÐµ for free, Ð¼Ñ‹ Ð²Ð¾Ð·ÑŒÐ¼ÐµÐ¼ Ð¾Ñ‚ Ð²Ð°Ñ Ð´ÐµÐ½ÑŒÐ³Ð¸ Ð² next time.',
            reply_markup=inline_pay
        )
        logger.debug("ÐžÑ‚Ð²ÐµÑ‚ Ð½Ð° /pay ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½.")
    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ /pay")
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /pay.")


@router.message(Command('mode'))
@processing_guard
async def mode_cmd(message: types.Message):
    try:
        reply_markup = await inline_modes(
            message.from_user.id,
            # curr_users_models
            db_client.get_user_model_by_tg_id(tg_id=message.from_user.id, ),
        )
        await message.answer(
            'Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰ÑƒÑŽ Ð²Ð°Ð¼ Ð¼Ð¾Ð´ÐµÐ»ÑŒ gpt.',
            reply_markup=reply_markup
        )
        logger.debug("ÐžÑ‚Ð²ÐµÑ‚ Ð½Ð° /mode ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½.")
    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ /mode")
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /mode.")


@router.message(Command('start'))
async def start_cmd(message: types.Message, state: FSMContext):
    try:
        us_id = message.from_user.id

        current_state = await state.get_state()
        if current_state is not None:
            await state.clear()
            await message.reply('Ð¤Ð¾Ñ‚Ð¾Ð³Ñ€Ð°Ñ„Ð¸Ñ cÐ±Ñ€Ð¾ÑˆÐµÐ½Ð°, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ Ð·Ð°Ð½Ð¾Ð²Ð¾ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ, Ð½Ð° ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð·Ð°Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð»Ð¸Ñ†Ð¾.')
            if us_id in id_in_processing:
                id_in_processing.remove(us_id)
                logger.debug(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {us_id} Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð» Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ.")
            return

        # Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ñ
        if db_client.user_is_new_by_tg_id(us_id):
            db_client.add_user(name=message.from_user.full_name, tg_id=us_id,
                               last_used_model='gpt-4o-mini')  # Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ full_name Ð¿ÑƒÑÑ‚Ð¾Ð¹
            chat_id = db_client.create_new_context_by_tg_id(tg_id=us_id)  # Ð½Ð¾Ð²Ñ‹Ð¹ Ñ‡Ð°Ñ‚ Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼ 'ÐŸÑƒÑÑ‚Ð¾Ð¹ Ñ‡Ð°Ñ‚'
            db_client.set_current_context_by_tg_id(tg_id=us_id, context_id=chat_id)

        await message.answer(message_templates['ru']['start'])
        logger.debug("ÐžÑ‚Ð²ÐµÑ‚ Ð½Ð° /start ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½.")

    except Exception as e:
        logger.debug(f'ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ /start')
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /start.")


@router.message(Command('profile'))
async def profile_command(message: Message):
    try:
        user_id = message.from_user.id
        username = message.from_user.username or "Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½"
        first_name = message.from_user.first_name or "Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½"
        last_name = message.from_user.last_name or "Ð½Ðµ ÑƒÐºÐ°Ð·Ð°Ð½"

        profile_info = (
            f"ðŸ‘¤ ÐŸÑ€Ð¾Ñ„Ð¸Ð»ÑŒ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ:\n"
            f"ID: {user_id}\n"
            f"Ð˜Ð¼Ñ: {first_name}\n"
            f"Ð¤Ð°Ð¼Ð¸Ð»Ð¸Ñ: {last_name}\n"
            f"Ð›Ð¾Ð³Ð¸Ð½: @{username}"
        )
        await message.answer(profile_info)
        logger.debug("ÐžÑ‚Ð²ÐµÑ‚ Ð½Ð° /profile ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½.")
    except Exception as e:
        logger.debug(f'ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ /profile')
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /profile.")


@router.message(Command('help'))
async def help_cmd(message: Message):
    try:
        await message.answer(message_templates['ru']['help'])
        logger.debug("ÐžÑ‚Ð²ÐµÑ‚ Ð½Ð° /help ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½.")
    except Exception as e:
        logger.debug(f'ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ /help')
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /help.")


@router.message(Command('new_context'))
@processing_guard
@block_not_llm_model
async def new_context(message: Message):
    try:
        chat_id = db_client.create_new_context_by_tg_id(tg_id=message.from_user.id)
        db_client.set_current_context_by_tg_id(tg_id=message.from_user.id, context_id=chat_id)
        await message.answer(message_templates['ru']['delete_context'])
        logger.debug("ÐžÑ‚Ð²ÐµÑ‚ Ð½Ð° /delete_context ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½.")
    except Exception as e:
        logger.debug(f'ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ /delete_context')
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ /delete_context.")


@router.callback_query(F.data.startswith('context:'))
@processing_guard
@block_not_llm_model
async def handle_context_switch(callback: types.CallbackQuery):
    try:
        context_id = callback.data.removeprefix("context:")
        us_id = callback.from_user.id

        context = db_client.get_current_context_by_tg_id(tg_id=us_id)
        topic = context.name
        db_client.set_current_context_by_tg_id(tg_id=us_id, context_id=context_id)

        # await callback.message.answer(get_changed_context_line(topic))

        context_history = db_client.make_context_history(chat_id=context_id)
        logger.info(f'Ð’Ñ‹Ð²ÐµÐ´ÐµÐ½Ð° context_history Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id}')

        if str(context_id) != str(context.id):
            await callback.message.edit_text(
                'ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚ Ð¸Ð· ÑÐ¿Ð¸ÑÐºÐ°.',
                reply_markup=await inline_contexts(us_id),
            )

        await callback.message.answer('Ð’Ð¾Ñ‚ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ð¼Ð¾Ðµ Ð²Ð°ÑˆÐµÐ³Ð¾ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°:')

        for msg in context_history:
            try:
                await callback.message.answer(msg, parse_mode="Markdown")
            except Exception as e:
                await callback.message.answer(msg)

        await callback.message.answer(get_changed_context_line(topic))

        await callback.answer()



    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ handle_context_switch")
        await callback.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¿ÐµÑ€ÐµÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ð¸ ÐºÐ¾Ð½Ñ‚ÐµÐºÑÑ‚Ð°.")


@router.callback_query(F.data.startswith('model:'))
@processing_guard
async def handle_model_switch(callback: types.CallbackQuery):
    try:
        model_name = callback.data.removeprefix("model:")
        us_id = callback.from_user.id
        if db_client.get_user_model_by_tg_id(us_id) != model_name:
            db_client.switch_user_model_by_tg_id(tg_id=us_id, new_model_name=model_name)

            await callback.message.edit_text(
                'Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´ÑÑ‰ÑƒÑŽ Ð²Ð°Ð¼ Ð¼Ð¾Ð´ÐµÐ»ÑŒ.',
                reply_markup=await inline_modes(us_id, db_client.get_user_model_by_tg_id(tg_id=us_id))
            )
            if model_name in ['dall-e-3']:
                curr_size = db_client.get_dalle_shape_by_tg_id(us_id)
                curr_resolution = db_client.get_dalle_quality_by_tg_id(us_id)
                await callback.message.answer(message_templates['ru']['dall_e_3_handler'],
                                              reply_markup=await dalle_3_settings(us_id, curr_resolution, curr_size))
            elif model_name in ['face-swap']:
                await callback.message.answer(message_templates['ru']['face-swap-1'])

            await callback.answer()
            logger.debug(f"ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id} ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð° Ð´Ð¾ {model_name}")
        else:
            await callback.answer()

    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ handle_model_switch")
        await callback.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¼ÐµÐ½Ðµ Ð¼Ð¾Ð´ÐµÐ»Ð¸.")


@router.callback_query(F.data.startswith('quality:'))
@processing_guard
@block_not_dalle_model
async def handle_dalle_3_quality_switch(callback: types.CallbackQuery):
    try:
        curr_quality = callback.data.removeprefix("quality:")
        us_id = callback.from_user.id
        if db_client.get_dalle_quality_by_tg_id(us_id) != curr_quality:
            db_client.set_dalle_quality_by_tg_id(tg_id=us_id, dalle_quality=curr_quality)

            await callback.message.edit_text(
                message_templates['ru']['dall_e_3_handler'],
                reply_markup=await dalle_3_settings(us_id, curr_quality, db_client.get_dalle_shape_by_tg_id(us_id))
            )
            await callback.answer()
            logger.debug(f"ÐšÐ°Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id} ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð° Ð´Ð¾ {curr_quality}")
        else:
            await callback.answer()

    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ handle_dalle_3_quality_switch")
        await callback.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¼ÐµÐ½Ðµ dalle_3_quality.")


@router.callback_query(F.data.startswith('resolution:'))
@processing_guard
@block_not_dalle_model
async def handle_dalle_3_resolution_switch(callback: types.CallbackQuery):
    try:
        curr_resolution = callback.data.removeprefix("resolution:")
        us_id = callback.from_user.id
        if db_client.get_dalle_shape_by_tg_id(us_id) != curr_resolution:
            db_client.set_dalle_shape_by_tg_id(us_id, dalle_shape=curr_resolution)

            await callback.message.edit_text(
                message_templates['ru']['dall_e_3_handler'],
                reply_markup=await dalle_3_settings(user_id=us_id, quality=db_client.get_dalle_quality_by_tg_id(us_id),
                                                    resolution=curr_resolution)
            )
            await callback.answer()
            logger.debug(f"ÐœÐ¾Ð´ÐµÐ»ÑŒ Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id} ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ð±Ð½Ð¾Ð²Ð»ÐµÐ½Ð° Ð´Ð¾ {curr_resolution}")
        else:
            await callback.answer()

    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ handle_dalle_3_resolution_switch")
        await callback.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ ÑÐ¼ÐµÐ½Ðµ Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð¸Ñ.")


async def openai_gpt_handler(message: Message, bot: Bot, state: FSMContext):
    logger.info(f"ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ openai Ð¾Ñ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {message.from_user.id}: {message.text}")
    us_id = message.from_user.id

    if not message.text:
        await message.answer("ÐŸÐ¾ÐºÐ° Ð¼Ñ‹ ÑƒÐ¼ÐµÐµÐ¼ Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‚ÐµÐºÑÑ‚")
        return

    try:
        user_message = message.text
        id_in_processing.add(us_id)

        if db_client.user_has_empty_curr_context_by_tg_id(us_id):
            chat_id = db_client.get_current_context_id_by_tg_id(tg_id=us_id)

            dialog_name = await request_get_topic(user_message)

            db_client.update_dialog_neame(chat_id=chat_id, dialog_name=dialog_name)

        curr_context_id = db_client.get_current_context_by_tg_id(us_id).id

        user_teg = message.from_user.username
        db_client.add_message(chat_id=curr_context_id, role='user', text=user_message, author_name=user_teg)

        processing_message = await message.answer(message_templates['ru']['processing'])

        await message.bot.send_chat_action(chat_id=message.chat.id, action="typing")

        response = await get_common_gpt_complection(
            db_client.get_full_dialog(curr_context_id)[-15:],
            db_client.get_user_model_by_tg_id(us_id)
        )

        logger.info(f"ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½ Ð¾Ñ‚Ð²ÐµÑ‚ Ð¾Ñ‚ OpenAI Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id}: {response}")

        await message.bot.delete_message(
            chat_id=processing_message.chat.id,
            message_id=processing_message.message_id
        )
        model_name = db_client.get_user_model_by_tg_id(us_id)
        db_client.add_message(chat_id=curr_context_id, role='assistant', text=response, author_name=model_name)

        # try:
        #     await message.answer(response, parse_mode="Markdown")
        # except Exception as e:
        #     await message.answer(response)
        await print_text_message(response, message)




    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ openai_gpt_handler Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id}")
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð²Ð°ÑˆÐµÐ³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ.")
    finally:
        if us_id in id_in_processing:
            id_in_processing.remove(us_id)
            logger.debug(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {us_id} Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð» Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð² openai_gpt_handler.")


async def cloude_text_model_handler(message: Message, bot: Bot, state: FSMContext):
    logger.info(f"ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð´Ð»Ñ anthropic Ð¾Ñ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {message.from_user.id}: {message.text}")
    us_id = message.from_user.id

    if not message.text:
        await message.answer("ÐŸÐ¾ÐºÐ° Ð¼Ñ‹ ÑƒÐ¼ÐµÐµÐ¼ Ð¿Ñ€Ð¸Ð½Ð¸Ð¼Ð°Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ñ‚ÐµÐºÑÑ‚")
        return

    try:
        user_message = message.text

        id_in_processing.add(us_id)

        if db_client.user_has_empty_curr_context_by_tg_id(us_id):
            chat_id = db_client.get_current_context_id_by_tg_id(tg_id=us_id)

            dialog_name = await request_get_topic(user_message)

            db_client.update_dialog_neame(chat_id=chat_id, dialog_name=dialog_name)

        curr_context_id = db_client.get_current_context_by_tg_id(us_id).id

        user_teg = message.from_user.username

        db_client.add_message(chat_id=curr_context_id, role='user', text=user_message, author_name=user_teg)

        processing_message = await message.answer(message_templates['ru']['processing'])

        await message.bot.send_chat_action(chat_id=message.chat.id, action="typing")

        response = await get_claude_text_response(
            db_client.get_full_dialog(curr_context_id)[-15:],
            db_client.get_user_model_by_tg_id(us_id)
        )

        logger.info(f"ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½ Ð¾Ñ‚Ð²ÐµÑ‚ Ð¾Ñ‚ cloude Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id}: {response}")

        await message.bot.delete_message(
            chat_id=processing_message.chat.id,
            message_id=processing_message.message_id
        )

        model_name = db_client.get_user_model_by_tg_id(us_id)
        db_client.add_message(chat_id=curr_context_id, role='assistant', text=response, author_name=model_name)

        # try:
        #     await message.answer(response, parse_mode="Markdown")
        # except Exception as e:
        #     await message.answer(response)
        await print_text_message(response, message)



    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ cloude_text_model_handler Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id}, {e}")
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð²Ð°ÑˆÐµÐ³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ.")
    finally:
        if us_id in id_in_processing:
            id_in_processing.remove(us_id)
            logger.debug(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {us_id} Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð» Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ Ð² cloude_text_model_handler.")


async def dall_e_3_handler(message: Message, bot: Bot, state: FSMContext):
    logger.info(f"ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¾Ñ‚ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {message.from_user.id}: {message.text} Ð´Ð»Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ")

    us_id = message.from_user.id
    # if us_id in id_in_processing:
    #     logger.warning(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {us_id} Ð¿Ñ‹Ñ‚Ð°ÐµÑ‚ÑÑ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð²Ð¾ Ð²Ñ€ÐµÐ¼Ñ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐ¸.")
    #     await message.answer(message_templates['ru']['id_in_procces'])
    #     return

    try:
        id_in_processing.add(us_id)

        processing_message = await message.answer(message_templates['ru']['processing'])
        await message.bot.send_chat_action(chat_id=message.chat.id, action="typing")

        curr_size = db_client.get_dalle_shape_by_tg_id(us_id)
        curr_quality = db_client.get_dalle_quality_by_tg_id(us_id)
        ans = await generate_image(message.text, model="dall-e-3", size=curr_size, quality=curr_quality)

        await message.bot.delete_message(
            chat_id=processing_message.chat.id,
            message_id=processing_message.message_id
        )

        if ans.startswith("http://") or ans.startswith("https://"):
            try:
                await message.answer_photo(ans, caption="Ð’Ð¾Ñ‚ Ð²Ð°ÑˆÐµ ÑÐ³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ðµ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ!")

            except Exception as e:
                await message.answer(f"ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ðµ")
        else:
            # Ð•ÑÐ»Ð¸ Ð¾Ñ‚Ð²ÐµÑ‚ openai API ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐµ
            await message.answer(f"Ð’Ð°Ñˆ Ð·Ð°Ð¿Ñ€Ð¾Ñ Ð½Ðµ Ð¿Ð¾Ð´Ñ…Ð¾Ð´Ð¸Ñ‚ Ð´Ð»Ñ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸")

        curr_size = db_client.get_dalle_shape_by_tg_id(us_id)
        curr_resolution = db_client.get_dalle_quality_by_tg_id(us_id)
        await message.answer(message_templates['ru']['dall_e_3_handler'],
                             reply_markup=await dalle_3_settings(us_id, curr_resolution, curr_size))



    except Exception as e:
        logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ ret_dalle_img Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id}")
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð²Ð°ÑˆÐµÐ³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ.")

    finally:
        if us_id in id_in_processing:
            id_in_processing.remove(us_id)
            logger.debug(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {us_id} Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð» Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ.")


class FaceSwap(StatesGroup):
    photo_1_done = State()


async def face_swap_handler_first_photo(message: Message, bot: Bot, state: FSMContext):
    us_id = message.from_user.id
    try:
        id_in_processing.add(us_id)
        photo = message.photo[-1]
        file_id = photo.file_id

        # ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¾ Ñ„Ð°Ð¹Ð»Ðµ Ñ ÑÐµÑ€Ð²ÐµÑ€Ð° Telegram
        file_info = await bot.get_file(file_id)

        # Ð¡ÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ðµ Ñ„Ð°Ð¹Ð»Ð° Ð¸ Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð² Base64
        async with aiohttp.ClientSession() as session:
            async with session.get(f"https://api.telegram.org/file/bot{BOT_TOKEN}/{file_info.file_path}") as response:
                if response.status == 200:
                    base64_encoded = base64.b64encode(await response.read()).decode("utf-8")

        # Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ ÑÑ‚Ñ€Ð¾ÐºÐ¸ Base64 Ð² ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ðµ FSM
        await state.update_data(photo_1_done=base64_encoded)

        await message.reply("ÐŸÐµÑ€Ð²Ð°Ñ Ñ„Ð¾Ñ‚Ð¾Ð³Ñ€Ð°Ñ„Ð¸Ñ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð°, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ Ñ„Ð¾Ñ‚Ð¾Ð³Ñ€Ð°Ñ„Ð¸ÑŽ Ñ Ð»Ð¸Ñ†Ð¾Ð¼."
                            "\nÐ•ÑÐ»Ð¸ Ð²Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ ÑÐ±Ñ€Ð¾ÑÐ¸Ñ‚ÑŒ ÑÑ‚Ñƒ Ñ„Ð¾Ñ‚Ð¾Ð³Ñ€Ð°Ñ„Ð¸ÑŽ, "
                            "Ð²Ð¾ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚ÐµÑÑŒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¾Ð¹ /start.")
        await state.set_state(FaceSwap.photo_1_done)

        await message.answer(message_templates['ru']['face-swap-2'])

    except Exception as e:
        # logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ face_swap_handler_first_photo Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id}")
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð²Ð°ÑˆÐµÐ³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð·.")
        await state.clear()
        if us_id in id_in_processing:
            id_in_processing.remove(us_id)


@router.message(FaceSwap.photo_1_done)
async def face_swap_handler_second_photo(message: Message, bot: Bot, state: FSMContext):
    try:

        us_id = message.from_user.id

        photo = message.photo[-1]
        file_id = photo.file_id

        processing_message = await message.reply(message_templates['ru']['processing'])
        await message.bot.send_chat_action(chat_id=message.chat.id, action="typing")

        # ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¾ Ñ„Ð°Ð¹Ð»Ðµ Ñ ÑÐµÑ€Ð²ÐµÑ€Ð° Telegram
        file_info = await bot.get_file(file_id)

        # Ð¡ÐºÐ°Ñ‡Ð¸Ð²Ð°Ð½Ð¸Ðµ Ñ„Ð°Ð¹Ð»Ð° Ð¸ Ð¿Ñ€ÐµÐ¾Ð±Ñ€Ð°Ð·Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð² Base64
        async with aiohttp.ClientSession() as session:
            async with session.get(f"https://api.telegram.org/file/bot{BOT_TOKEN}/{file_info.file_path}") as response:
                if response.status == 200:
                    base64_encoded = base64.b64encode(await response.read()).decode("utf-8")

        # ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð¿ÐµÑ€Ð²Ð¾Ð¹ Ñ„Ð¾Ñ‚Ð¾Ð³Ñ€Ð°Ñ„Ð¸Ð¸ Ð¸Ð· ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ FSM
        data = await state.get_data()
        img_1_base64 = data.get('photo_1_done')
        img_2_base64 = base64_encoded

        # ÐžÑ‡Ð¸ÑÑ‚ÐºÐ° ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ FSM
        await state.clear()

        url = await run_face_swap(img_1_base64, img_2_base64)
        if url == None:
            await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ð¸ Ð¸Ð·Ð¾Ð±Ñ€Ð°Ð¶ÐµÐ½Ð¸Ñ,"
                                 "Ð·Ð°Ð½Ð¾Ð²Ð¾ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ Ñ„Ð¾Ñ‚Ð¾, Ð½Ð° ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð¼ Ð½ÑƒÐ¶Ð½Ð¾ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð»Ð¸Ñ†Ð¾.")
            # ÐžÑ‡Ð¸ÑÑ‚ÐºÐ° ÑÐ¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ FSM
            await state.clear()
            if us_id in id_in_processing:
                id_in_processing.remove(us_id)
                logger.debug(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {us_id} Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð» Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ.")
                await message.answer(message_templates['ru']['face-swap-1'])
            return

        await message.answer_photo(url)

        await message.bot.delete_message(
            chat_id=processing_message.chat.id,
            message_id=processing_message.message_id
        )

        await message.answer(message_templates['ru']['face-swap-1'])

        if us_id in id_in_processing:
            id_in_processing.remove(us_id)
            logger.debug(f"ÐŸÐ¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ {us_id} Ð·Ð°Ð²ÐµÑ€ÑˆÐ¸Ð» Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÑƒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ.")


    except Exception as e:
        # logger.debug(f"ÐžÑˆÐ¸Ð±ÐºÐ° Ð² Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ñ‡Ð¸ÐºÐµ face_swap_handler_first_photo Ð´Ð»Ñ Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»Ñ {us_id}")
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ Ð²Ð°ÑˆÐµÐ³Ð¾ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ñ, Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ ÐµÑ‰Ðµ Ñ€Ð°Ð·.")


model_handler = {  # Ð´Ð»Ñ Ð½ÐµÐ¹Ñ€Ð¾Ð½ÐºÐ¸ Ñ…Ñ€Ð°Ð½Ð¸Ð¼ Ñ…ÐµÐ½Ð´Ð»ÐµÑ€
    'gpt-4o-mini': openai_gpt_handler,
    'gpt-4o': openai_gpt_handler,
    'o1-mini': openai_gpt_handler,
    'o1-preview': openai_gpt_handler,
    'dall-e-3': dall_e_3_handler,
    'face-swap': face_swap_handler_first_photo,
    'claude-3-5-sonnet-latest': cloude_text_model_handler,
    'claude-3-5-haiku-latest': cloude_text_model_handler
}


@router.message()
@processing_guard
async def echo_msg(message: Message, bot: Bot, state: FSMContext):
    try:
        # Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð°Ñ†Ð¸Ñ
        us_id = message.from_user.id
        if db_client.user_is_new_by_tg_id(us_id):
            db_client.add_user(name=message.from_user.full_name, tg_id=us_id,
                               last_used_model='gpt-4o-mini')  # Ð²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ full_name Ð¿ÑƒÑÑ‚Ð¾Ð¹
            chat_id = db_client.create_new_context_by_tg_id(tg_id=us_id)  # Ð½Ð¾Ð²Ñ‹Ð¹ Ñ‡Ð°Ñ‚ Ñ Ð½Ð°Ð·Ð²Ð°Ð½Ð¸ÐµÐ¼ 'ÐŸÑƒÑÑ‚Ð¾Ð¹ Ñ‡Ð°Ñ‚'
            db_client.set_current_context_by_tg_id(tg_id=us_id, context_id=chat_id)

    except Exception as e:
        logger.debug(f'ÐžÑˆÐ¸Ð±ÐºÐ°: Ð¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÐµÐ»ÑŒ Ð½Ðµ Ð·Ð°Ñ€ÐµÐ³ÐµÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ð½')
        await message.answer("ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚ÐºÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹.")

    last_used_model = db_client.get_user_model_by_tg_id(message.from_user.id)
    logging.debug(f'Ð”ÐµÐ±Ð°Ð³ - {last_used_model}')

    await model_handler[last_used_model](message, bot, state)
